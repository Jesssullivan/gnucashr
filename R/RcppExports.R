# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Convert Fractions to Double
#'
#' Vectorized conversion of GnuCash fraction representation to double.
#' This is a hot path in balance calculations, hence Rcpp implementation.
#'
#' @param numerator Integer vector of numerators (value_num)
#' @param denominator Integer vector of denominators (value_denom)
#' @return NumericVector of double values
#' @export
fraction_to_double <- function(numerator, denominator) {
    .Call(`_gnucashr_fraction_to_double`, numerator, denominator)
}

#' Convert Double to Fraction
#'
#' Convert decimal values to fractions with specified precision.
#' Default denominator of 100 for currency (cents precision).
#'
#' @param value NumericVector of decimal values
#' @param denom Target denominator (default 100 for cents)
#' @return IntegerMatrix with columns: numerator, denominator
#' @export
double_to_fraction <- function(value, denom = 100L) {
    .Call(`_gnucashr_double_to_fraction`, value, denom)
}

#' Add Two Fractions
#'
#' Vectorized fraction addition maintaining exact representation.
#' Used for accumulating balances without floating-point drift.
#'
#' @param num1 First numerator vector
#' @param denom1 First denominator vector
#' @param num2 Second numerator vector
#' @param denom2 Second denominator vector
#' @return IntegerMatrix with columns: numerator, denominator
#' @export
add_fractions <- function(num1, denom1, num2, denom2) {
    .Call(`_gnucashr_add_fractions`, num1, denom1, num2, denom2)
}

#' Validate Splits Balance
#'
#' Verify that splits in a transaction sum to zero (double-entry principle).
#' Returns TRUE if balanced, FALSE otherwise.
#'
#' @param numerators Integer vector of split value_num
#' @param denominators Integer vector of split value_denom
#' @return Logical indicating if splits balance to zero
#' @export
validate_splits_balance <- function(numerators, denominators) {
    .Call(`_gnucashr_validate_splits_balance`, numerators, denominators)
}

#' Generate GnuCash-Format GUID
#'
#' Generate a random 32-character hex GUID in GnuCash format.
#' GnuCash uses lowercase hex without dashes.
#'
#' @return Character string with 32-character hex GUID
#' @export
generate_guid <- function() {
    .Call(`_gnucashr_generate_guid`)
}

#' Validate GnuCash GUID Format
#'
#' Check if a string is a valid 32-character hex GUID.
#'
#' @param guid Character string to validate
#' @return Logical indicating validity
#' @export
validate_guid <- function(guid) {
    .Call(`_gnucashr_validate_guid`, guid)
}

#' Generate Multiple GUIDs
#'
#' Vectorized GUID generation for batch operations.
#'
#' @param n Number of GUIDs to generate
#' @return CharacterVector of GUIDs
#' @export
generate_guids <- function(n) {
    .Call(`_gnucashr_generate_guids`, n)
}

#' Parallel Monte Carlo Simulation
#'
#' Run Monte Carlo simulation for financial projections using parallel execution.
#' Uses RcppParallel with thread-local RNG for reproducible, deterministic results.
#'
#' @param base_revenue Starting monthly revenue
#' @param base_expense_rate Base expense ratio (0-1)
#' @param n_sims Number of simulations to run (default 10000)
#' @param n_periods Number of periods to project (default 12)
#' @param growth_mean Mean monthly growth rate (default 0.05 = 5%)
#' @param growth_sd Standard deviation of growth (default 0.03)
#' @param expense_mean Mean expense ratio (default matches base_expense_rate)
#' @param expense_sd Standard deviation of expense ratio (default 0.05)
#' @param seed Master seed for reproducibility (default 42)
#' @return List with: results (matrix), final_cash (vector), summary (quantiles)
#' @export
monte_carlo_parallel <- function(base_revenue, base_expense_rate, n_sims = 10000L, n_periods = 12L, growth_mean = 0.05, growth_sd = 0.03, expense_mean = -1.0, expense_sd = 0.05, seed = 42L) {
    .Call(`_gnucashr_monte_carlo_parallel`, base_revenue, base_expense_rate, n_sims, n_periods, growth_mean, growth_sd, expense_mean, expense_sd, seed)
}

#' Multi-Entity Parallel Monte Carlo
#'
#' Run Monte Carlo simulation for multiple entities with correlated growth.
#'
#' @param base_revenues NumericVector of starting revenues per entity
#' @param growth_means NumericVector of mean growth rates per entity
#' @param growth_sds NumericVector of growth standard deviations per entity
#' @param expense_rates NumericVector of expense ratios per entity
#' @param n_sims Number of simulations (default 10000)
#' @param n_periods Number of periods (default 12)
#' @param seed Master seed for reproducibility
#' @return List with entity_results, total_cash, and summary
#' @export
monte_carlo_multi_entity <- function(base_revenues, growth_means, growth_sds, expense_rates, n_sims = 10000L, n_periods = 12L, seed = 42L) {
    .Call(`_gnucashr_monte_carlo_multi_entity`, base_revenues, growth_means, growth_sds, expense_rates, n_sims, n_periods, seed)
}

#' Detect OFX File Version
#'
#' Determine whether an OFX file is version 1.x (SGML) or 2.x (XML).
#'
#' @param content String content of the OFX file
#' @return String: "1" for SGML, "2" for XML, "unknown" otherwise
#' @export
detect_ofx_version_cpp <- function(content) {
    .Call(`_gnucashr_detect_ofx_version_cpp`, content)
}

#' Parse OFX Content
#'
#' Parse OFX/QFX file content and extract transaction data.
#' Handles both OFX 1.x (SGML) and 2.x (XML) formats.
#'
#' @param content String content of the OFX file
#' @return List with vectors: dates, amounts, names, fitids, memos, trntype, currency
#' @export
parse_ofx_cpp <- function(content) {
    .Call(`_gnucashr_parse_ofx_cpp`, content)
}

#' Extract OFX Account Info
#'
#' Extract account information from OFX content (ACCTID, BANKID, etc.)
#'
#' @param content String content of the OFX file
#' @return List with account_id, bank_id, account_type, org_name
#' @export
extract_ofx_account_info <- function(content) {
    .Call(`_gnucashr_extract_ofx_account_info`, content)
}

#' Parallel Scenario Projection
#'
#' Project multiple growth scenarios in parallel for each entity.
#'
#' @param base_values Starting values per entity
#' @param growth_matrix Matrix of growth rates (scenarios x entities)
#' @param n_periods Number of periods to project
#' @return List with results matrix, final totals, and metadata
#' @export
parallel_project_scenarios <- function(base_values, growth_matrix, n_periods = 12L) {
    .Call(`_gnucashr_parallel_project_scenarios`, base_values, growth_matrix, n_periods)
}

#' Parallel Sensitivity Grid
#'
#' Compute sensitivity grid for growth rate and expense ratio combinations.
#' Efficient for large parameter sweeps.
#'
#' @param base_revenue Starting revenue
#' @param base_expense_rate Base expense ratio
#' @param growth_range Vector of growth rates to test
#' @param expense_range Vector of expense ratios to test
#' @param n_periods Number of periods to project
#' @return List with outcomes matrix and ranges
#' @export
parallel_sensitivity_grid <- function(base_revenue, base_expense_rate, growth_range, expense_range, n_periods = 12L) {
    .Call(`_gnucashr_parallel_sensitivity_grid`, base_revenue, base_expense_rate, growth_range, expense_range, n_periods)
}

#' Batch Growth Projection
#'
#' Project growth for many initial values with same parameters.
#' Useful for account-level projections.
#'
#' @param initial_values Vector of starting values
#' @param growth_rate Monthly growth rate
#' @param expense_rate Expense ratio (0-1)
#' @param n_periods Number of periods
#' @return List with projections matrix and final values
#' @export
batch_project_growth <- function(initial_values, growth_rate, expense_rate, n_periods = 12L) {
    .Call(`_gnucashr_batch_project_growth`, initial_values, growth_rate, expense_rate, n_periods)
}

#' Sequential Projection (Non-Parallel Fallback)
#'
#' Single-threaded projection for testing and comparison.
#'
#' @param base_revenue Starting revenue
#' @param growth_rate Monthly growth rate
#' @param expense_rate Expense ratio
#' @param n_periods Number of periods
#' @return NumericVector of cumulative cash by period
#' @export
sequential_projection <- function(base_revenue, growth_rate, expense_rate, n_periods = 12L) {
    .Call(`_gnucashr_sequential_projection`, base_revenue, growth_rate, expense_rate, n_periods)
}

#' Validate Transaction Balance
#'
#' Check that a set of split values sum to zero (double-entry principle).
#' Uses exact integer arithmetic to avoid floating-point errors.
#'
#' @param value_nums Integer vector of split value numerators
#' @param value_denoms Integer vector of split value denominators
#' @param tolerance Maximum allowed imbalance (default 0, strict)
#' @return List with: balanced (bool), total (double), message (string)
#' @export
validate_transaction_balance <- function(value_nums, value_denoms, tolerance = 0.0) {
    .Call(`_gnucashr_validate_transaction_balance`, value_nums, value_denoms, tolerance)
}

#' Validate Account GUID Format
#'
#' Check if a string is a valid GnuCash GUID (32 hex characters).
#'
#' @param guids Character vector of GUIDs to validate
#' @return Logical vector indicating validity
#' @export
validate_guids <- function(guids) {
    .Call(`_gnucashr_validate_guids`, guids)
}

#' Check for Duplicate GUIDs
#'
#' Verify that all GUIDs in a vector are unique.
#'
#' @param guids Character vector of GUIDs
#' @return List with: unique (bool), duplicates (character vector)
#' @export
check_guid_uniqueness <- function(guids) {
    .Call(`_gnucashr_check_guid_uniqueness`, guids)
}

#' Validate Split Values
#'
#' Check that split values are valid (non-zero, proper fractions).
#'
#' @param value_nums Integer vector of numerators
#' @param value_denoms Integer vector of denominators
#' @return List with validation results
#' @export
validate_split_values <- function(value_nums, value_denoms) {
    .Call(`_gnucashr_validate_split_values`, value_nums, value_denoms)
}

#' Calculate Running Balance
#'
#' Calculate running balance for a series of transactions.
#' Optimized for large transaction histories.
#'
#' @param value_nums Integer vector of value numerators
#' @param value_denoms Integer vector of value denominators
#' @param opening_balance Starting balance (default 0)
#' @return NumericVector of running balances
#' @export
calculate_running_balance <- function(value_nums, value_denoms, opening_balance = 0.0) {
    .Call(`_gnucashr_calculate_running_balance`, value_nums, value_denoms, opening_balance)
}

