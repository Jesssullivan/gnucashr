---
title: "Financial Forecasting"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Financial Forecasting}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  eval = FALSE
)
```

## Introduction

gnucashr provides a lazy forecasting system that builds computation pipelines
without executing until you call `collect()`. This enables efficient scenario
comparison, Monte Carlo simulation, and sensitivity analysis.

## The LazyForecast Pattern

```{r lazy-basic}
library(gnucashr)

# Define entity configuration
config <- list(
  entities = list(
    corp = list(
      revenue = 100000,
      operating_rate = 0.70,
      cogs_rate = 0.25,
      growth_rate = 0.05
    )
  )
)

# Build a lazy forecast - NO computation yet
forecast <- forecast_expr(config) |>
  lf_grow(rate = 0.05, months = 12)

# Inspect the plan without executing
forecast$show_plan()
# <LazyForecast Plan>
# Source: config
# Operations:
#   1. grow (rate=5.00%, months=12)
# Materialized: FALSE

# Execute the forecast
result <- lf_collect(forecast)
```

## Data Sources

Forecasts can be built from multiple sources:

```{r sources}
# From entity configuration
f1 <- forecast_expr(config)

# From a GnuCash book
gc <- read_gnucash("books.gnucash")
f2 <- from_book(gc)

# From a book collection
collection <- book_collection()
collection$add_book("corp", "corp.gnucash")
f3 <- from_collection(collection)

# From raw data
data <- tibble::tibble(
  entity = "corp",
  revenue = 100000,
  expenses = 70000
)
f4 <- from_data(data)
```

## Growth Projections

```{r growth}
# Simple growth projection
result <- forecast_expr(config) |>
  lf_grow(rate = 0.05, months = 12) |>
  lf_collect()

# View projections
result$projections

# Compound vs simple growth
compound <- forecast_expr(config) |>
  lf_grow(rate = 0.05, months = 12, compound = TRUE) |>
  lf_collect()

simple <- forecast_expr(config) |>
  lf_grow(rate = 0.05, months = 12, compound = FALSE) |>
  lf_collect()
```

## Scenario Comparison

Compare multiple scenarios without duplicating computation:

```{r scenarios}
# Define scenarios
base <- forecast_expr(config) |>
  lf_grow(rate = 0.05, months = 12)

optimistic <- forecast_expr(config) |>
  lf_grow(rate = 0.08, months = 12)

pessimistic <- forecast_expr(config) |>
  lf_grow(rate = 0.02, months = 12)

# Compare scenarios
comparison <- compare_forecasts(
  base = base,
  optimistic = optimistic,
  pessimistic = pessimistic
)

# Access results
comparison$base$cumulative_revenue
comparison$optimistic$cumulative_revenue
comparison$pessimistic$cumulative_revenue
```

## Monte Carlo Simulation

Run thousands of simulations with uncertain parameters:

```{r monte-carlo}
# Build Monte Carlo forecast
mc_forecast <- forecast_expr(config) |>
  lf_monte_carlo(
    n = 10000,
    params = list(
      growth = list(mean = 0.05, sd = 0.03),
      expense = list(mean = 0.70, sd = 0.05)
    ),
    seed = 42
  )

# Execute (uses parallel Rcpp backend)
mc_result <- lf_collect(mc_forecast)

# Summary statistics
mc_result$summary
# Returns quantiles: p5, p25, p50, p75, p95

# Extract specific quantile
median_outcome <- extract_quantile(mc_result, 0.50)
worst_case <- extract_quantile(mc_result, 0.05)
best_case <- extract_quantile(mc_result, 0.95)

# Visualize
plot_monte_carlo(mc_result, title = "12-Month Cash Flow Projection")
```

### Quick Monte Carlo

For simple cases without building a full pipeline:

```{r quick-mc}
# Quick Monte Carlo from config
result <- quick_monte_carlo(
  config,
  n_sims = 10000,
  n_periods = 12,
  growth_mean = 0.05,
  growth_sd = 0.03,
  seed = 42
)

# Returns same structure as lf_monte_carlo
```

## Sensitivity Analysis

Analyze how outcomes change with different parameters:

```{r sensitivity}
# Build sensitivity analysis
sens_forecast <- forecast_expr(config) |>
  lf_sensitivity(
    growth_range = seq(-0.02, 0.10, 0.01),
    expense_range = seq(0.60, 0.80, 0.02)
  )

# Execute (uses parallel Rcpp backend)
sens_result <- lf_collect(sens_forecast)

# Access outcomes matrix
sens_result$outcomes  # growth Ã— expense matrix

# Visualize as heatmap
plot_sensitivity(sens_result, title = "Sensitivity to Growth and Expense Rates")
```

### Quick Sensitivity

```{r quick-sens}
# Quick sensitivity from config
result <- quick_sensitivity(
  config,
  growth_range = seq(-0.02, 0.10, 0.01),
  expense_range = seq(0.60, 0.80, 0.02),
  n_periods = 12
)
```

## Multi-Entity Forecasting

Forecast across multiple entities:

```{r multi-entity}
# Configuration with multiple entities
multi_config <- list(
  entities = list(
    products = list(revenue = 50000, growth_rate = 0.05, operating_rate = 0.65),
    services = list(revenue = 70000, growth_rate = 0.08, operating_rate = 0.60),
    software = list(revenue = 7000, growth_rate = 0.05, operating_rate = 0.30)
  )
)

# Forecast all entities
result <- forecast_expr(multi_config) |>
  lf_grow(rate = "growth_rate", months = 12) |>
  lf_collect()

# Results by entity
result$projections$products
result$projections$services
result$projections$software

# Monte Carlo across all entities
mc_result <- monte_carlo_multi_entity(
  multi_config,
  n_sims = 10000,
  n_periods = 12,
  params = list(
    growth_sd = 0.03,
    expense_sd = 0.05
  )
)
```

## Parallel Execution

gnucashr uses RcppParallel for high-performance simulations:

```{r parallel}
# Parallel Monte Carlo (default)
mc_result <- forecast_expr(config) |>
  lf_monte_carlo(n = 10000, params = params) |>
  lf_collect(parallel = TRUE)

# Sequential execution (for debugging)
mc_result <- forecast_expr(config) |>
  lf_monte_carlo(n = 10000, params = params) |>
  lf_collect(parallel = FALSE)

# Parallel scenario projection
scenarios <- parallel_project_scenarios(
  base_revenue = c(50000, 70000, 7000),  # By entity
  growth_matrix = matrix(
    c(0.03, 0.05, 0.08),  # Low, base, high
    nrow = 3, ncol = 3, byrow = TRUE
  ),
  n_periods = 12
)
```

## Audited Forecasting

Track all forecast operations with audit logging:

```{r audited}
# Create audited forecast
forecast <- forecast_expr(config) |>
  lf_grow(rate = 0.05, months = 12)

# Collect with audit trail
result <- audited_forecast(forecast, "Q1 2025 Base Case")
result <- audited_collect(result)

# Get data and log
data <- logged_value(result)
log <- logged_log(result)

# Write audit trail
write_forecast_audit(result, "forecast-audit.txt")
```

## Safe Error Handling

Use the Result monad for safe operations:

```{r safe}
# Safe Monte Carlo
result <- safe_quick_monte_carlo(config, n_sims = 10000)

result_match(result,
  ok_fn = function(data) {
    message("Median outcome: ", format_currency(data$summary$p50))
  },
  err_fn = function(e) {
    warning("Simulation failed: ", e)
  }
)

# Safe sensitivity
result <- safe_quick_sensitivity(config)
if (is_ok(result)) {
  plot_sensitivity(unwrap(result))
}
```

## Reactive Forecasting for Quarto

```{r reactive}
library(shiny)

# Reactive configuration
config_reactive <- reactive({
  list(
    entities = list(
      corp = list(
        revenue = input$revenue,
        growth_rate = input$growth,
        operating_rate = input$operating
      )
    )
  )
})

# Reactive forecast
forecast_result <- reactive_forecast(
  config_reactive,
  reactive(input$growth_rate),
  months = 12
)

# Reactive Monte Carlo
mc_result <- reactive_monte_carlo(
  config_reactive,
  n_sims = 10000,
  reactive(input$growth_mean),
  reactive(input$growth_sd)
)

# Use in outputs
output$forecast_plot <- renderPlot({
  plot_monte_carlo(mc_result())
})
```

## Performance Benchmarks

gnucashr achieves significant speedups with RcppParallel:

| Operation | R (serial) | Rcpp (parallel) | Speedup |
|-----------|------------|-----------------|---------|
| Monte Carlo 10K sims | ~3 sec | ~0.05 sec | **60x** |
| Sensitivity 125 scenarios | ~5 sec | ~0.5 sec | **10x** |
| 5-scenario comparison | ~0.5 sec | ~0.1 sec | **5x** |

## Best Practices

1. **Build Lazy, Execute Once**: Compose your forecast pipeline, then call
   `lf_collect()` only when you need results.

2. **Use Deterministic Seeds**: Always set `seed` for reproducible Monte Carlo
   results.

3. **Parallel by Default**: Leave `parallel = TRUE` for production; use
   `parallel = FALSE` only for debugging.

4. **Audit Important Forecasts**: Use `audited_forecast()` for any projections
   that will be shared or used for decisions.

5. **Validate Inputs**: Use `validate_forecast_params()` before running
   expensive simulations.

## Next Steps

- [Getting Started](getting-started.html): Basic gnucashr usage
- [Multi-Book Consolidation](consolidation.html): Managing multiple entities
