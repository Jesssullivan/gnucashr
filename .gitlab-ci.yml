# GitLab CI/CD Pipeline for gnucashr R Package
# Primary CI pipeline - GitLab CI
# Secondary CI pipeline - GitHub Actions

image: rocker/tidyverse:4.4.0

variables:
  R_LIBS_USER: "$CI_PROJECT_DIR/ci/lib"
  _R_CHECK_CRAN_INCOMING_REMOTE_: "false"
  _R_CHECK_FORCE_SUGGESTS_: "false"
  R_CHECK_ARGS: "--no-manual --as-cran"
  MAKEFLAGS: "-j2"

cache:
  key: "${CI_COMMIT_REF_SLUG}"
  paths:
    - $R_LIBS_USER
    - src/*.o

stages:
  - check
  - test
  - coverage
  - deploy

# Install system dependencies and R packages
.setup: &setup
  before_script:
    - mkdir -p $R_LIBS_USER
    # System dependencies for Rcpp/RcppParallel/RcppArmadillo
    - apt-get update -qq && apt-get install -y -qq libcurl4-openssl-dev libssl-dev libxml2-dev libgit2-dev libblas-dev liblapack-dev
    # Install R dependencies
    - |
      Rscript -e '
        options(repos = c(CRAN = "https://cloud.r-project.org"))
        install.packages(c("remotes", "knitr", "rmarkdown"), lib = Sys.getenv("R_LIBS_USER"))
        library(remotes)
        remotes::install_deps(dependencies = TRUE, upgrade = "always")
      '

# R CMD check - the main package validation
r-cmd-check:
  stage: check
  timeout: 2h
  <<: *setup
  script:
    - |
      Rscript -e '
        options(repos = c(CRAN = "https://cloud.r-project.org"))
        install.packages(c("rcmdcheck", "devtools", "knitr", "rmarkdown"), lib = Sys.getenv("R_LIBS_USER"))
        library(rcmdcheck)
        rcmdcheck::rcmdcheck(
          args = c("--no-manual", "--as-cran", "--ignore-vignettes"),
          build_args = c("--no-manual", "--no-build-vignettes"),
          error_on = "error",
          check_dir = "check"
        )
      '
  artifacts:
    paths:
      - check/
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Run testthat tests
test:
  stage: test
  timeout: 2h
  <<: *setup
  script:
    - |
      Rscript -e '
        options(repos = c(CRAN = "https://cloud.r-project.org"))
        library(devtools)
        # Run tests from source directory with JUnit output
        results <- devtools::test(reporter = testthat::JunitReporter$new(file = "test-results.xml"))
        # Check for failures
        if (any(as.data.frame(results)$failed > 0)) {
          quit(status = 1)
        }
      '
  artifacts:
    reports:
      junit: test-results.xml
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Code coverage with covr
coverage:
  stage: coverage
  <<: *setup
  script:
    - |
      Rscript -e '
        options(repos = c(CRAN = "https://cloud.r-project.org"))
        install.packages("covr", lib = Sys.getenv("R_LIBS_USER"))
        library(covr)

        cov <- package_coverage(
          type = "tests",
          line_exclusions = list("src/RcppExports.cpp")
        )

        # Generate coverage report
        report <- coverage_to_list(cov)
        total_coverage <- attr(cov, "package")$filecoverage
        message(sprintf("Total coverage: %.1f%%", mean(total_coverage) * 100))

        # Save coverage report as cobertura XML for GitLab
        to_cobertura(cov, filename = "coverage.xml")

        # Upload to Codecov if token is available
        if (Sys.getenv("CODECOV_TOKEN") != "") {
          codecov(token = Sys.getenv("CODECOV_TOKEN"))
        }
      '
  coverage: '/Total coverage: (\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Build pkgdown documentation site
pages:
  stage: deploy
  <<: *setup
  script:
    - |
      Rscript -e '
        options(repos = c(CRAN = "https://cloud.r-project.org"))
        install.packages(c("pkgdown", "devtools"), lib = Sys.getenv("R_LIBS_USER"))
        library(pkgdown)

        # Build documentation site
        pkgdown::build_site(override = list(destination = "public"))
      '
  artifacts:
    paths:
      - public
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  environment:
    name: production
    url: $CI_PAGES_URL

# CRAN-ready check (stricter, for releases)
cran-check:
  stage: check
  timeout: 2h
  <<: *setup
  script:
    - |
      Rscript -e '
        options(repos = c(CRAN = "https://cloud.r-project.org"))
        install.packages(c("spelling", "urlchecker", "goodpractice"), lib = Sys.getenv("R_LIBS_USER"))

        # Spelling check
        message("=== Spelling Check ===")
        spell_errors <- spelling::spell_check_package()
        if (nrow(spell_errors) > 0) {
          print(spell_errors)
          message("Add valid words to inst/WORDLIST")
        }

        # URL check
        message("=== URL Check ===")
        url_results <- urlchecker::url_check()
        if (!is.null(url_results) && nrow(url_results) > 0) {
          print(url_results)
        }

        # Full CRAN check (NOTEs and warnings are allowed, only errors fail)
        message("=== R CMD check --as-cran ===")
        results <- devtools::check(cran = TRUE, error_on = "error")
      '
  artifacts:
    paths:
      - "*.Rcheck/"
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+/
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: true

# Build source package for release
build-package:
  stage: deploy
  <<: *setup
  script:
    - |
      Rscript -e '
        options(repos = c(CRAN = "https://cloud.r-project.org"))
        pkg <- devtools::build()
        # Get version from DESCRIPTION
        desc <- read.dcf("DESCRIPTION")
        version <- desc[1, "Version"]
        pkg_name <- paste0("gnucashr_", version, ".tar.gz")
        file.copy(pkg, pkg_name)
        message("Built package: ", pkg_name)
      '
  artifacts:
    paths:
      - gnucashr_*.tar.gz
    expire_in: 3 months
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+/

# Create GitLab release
release:
  stage: deploy
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - job: build-package
      artifacts: true
    - job: cran-check
      artifacts: false
  script:
    - echo "Creating release for ${CI_COMMIT_TAG}"
  release:
    tag_name: $CI_COMMIT_TAG
    name: "gnucashr ${CI_COMMIT_TAG}"
    description: |
      ## gnucashr ${CI_COMMIT_TAG}

      See NEWS.md for full changelog.

      ### Installation

      From CRAN (after acceptance):
      ```r
      install.packages("gnucashr")
      ```

      From GitLab:
      ```r
      remotes::install_gitlab("tinyland/projects/gnucashr@${CI_COMMIT_TAG}")
      ```

      From GitHub:
      ```r
      remotes::install_github("Jesssullivan/gnucashr@${CI_COMMIT_TAG}")
      ```
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/
