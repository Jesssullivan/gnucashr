# GitLab CI/CD Pipeline for gnucashr R Package
# Primary CI pipeline - GitLab CI
# Optimized for speed with pak and Posit Package Manager

image: rocker/tidyverse:4.4.0

# Target x86_64 Docker runners - rocker images don't have ARM64 builds
default:
  tags:
    - linux
    - docker

variables:
  R_LIBS_USER: "$CI_PROJECT_DIR/ci/lib"
  # Use Posit Package Manager for fast binary installs
  RSPM: "https://packagemanager.posit.co/cran/__linux__/jammy/latest"
  _R_CHECK_CRAN_INCOMING_REMOTE_: "false"
  _R_CHECK_FORCE_SUGGESTS_: "false"
  # Parallel compilation for Rcpp packages
  MAKEFLAGS: "-j4"
  NCPUS: "4"
  # pak settings for faster installs
  PKG_SYSREQS: "true"
  PKG_SYSREQS_DRY_RUN: "false"
  # Avoid re-downloading packages
  R_PKG_CACHE_DIR: "$CI_PROJECT_DIR/ci/pkg-cache"

cache:
  # Use stable key for better cache reuse across branches
  key: "r-deps-v3"
  paths:
    - ci/lib
    - ci/pkg-cache
    - src/*.o
    - src/*.so
  policy: pull-push

stages:
  - check
  - test
  - coverage
  - deploy

# Nix-based build template for reproducible environments
.nix_base:
  image: nixos/nix:latest
  tags:
    - linux
    - docker
  variables:
    NIX_CONFIG: |
      experimental-features = nix-command flakes
      accept-flake-config = true
      extra-substituters = https://nix-cache.fuzzy-dev.tinyland.dev/main
      extra-trusted-public-keys = main:PBDvqG8OP3W2XF4QzuqWwZD/RhLRsE7ONxwM09kqTtw=
  before_script:
    - nix --version
    # Attic cache configured via NIX_CONFIG above (uses flake.nix nixConfig)
    # For push access, set ATTIC_TOKEN in GitLab CI variables:
    # - nix profile install nixpkgs#attic-client
    # - attic login tinyland https://nix-cache.fuzzy-dev.tinyland.dev $ATTIC_TOKEN

# Optimized setup with pak - skip install if dependencies cached
.setup: &setup
  before_script:
    - mkdir -p $R_LIBS_USER
    # System dependencies for Rcpp/RcppParallel/RcppArmadillo
    - apt-get update -qq && apt-get install -y -qq libcurl4-openssl-dev libssl-dev libxml2-dev libgit2-dev libblas-dev liblapack-dev
    # Install pak and dependencies with smart caching
    - |
      Rscript -e '
        options(repos = c(RSPM = Sys.getenv("RSPM"), CRAN = "https://cloud.r-project.org"))
        # Check if core packages already installed
        core_pkgs <- c("Rcpp", "RcppParallel", "RcppArmadillo", "DBI", "RSQLite")
        installed <- vapply(core_pkgs, requireNamespace, logical(1), quietly = TRUE)

        if (all(installed)) {
          message("Core dependencies cached, checking for updates only...")
          needs_install <- FALSE
        } else {
          message("Installing missing core dependencies: ", paste(core_pkgs[!installed], collapse = ", "))
          needs_install <- TRUE
        }

        if (!requireNamespace("pak", quietly = TRUE)) {
          install.packages("pak", repos = sprintf("https://r-lib.github.io/p/pak/stable/%s/%s/%s", .Platform$pkgType, R.Version()$os, R.Version()$arch))
        }

        if (needs_install) {
          pak::pkg_install("local::.", dependencies = TRUE, upgrade = FALSE)
        } else {
          # Quick check for any missing deps without full resolution
          pak::pkg_install("local::.", dependencies = TRUE, upgrade = FALSE)
        }
      '


# R CMD check - the main package validation
# Note: Full CRAN-like check runs on GitHub Actions matrix
# GitLab check is streamlined for faster feedback
r-cmd-check:
  stage: check
  timeout: 60m
  <<: *setup
  script:
    - |
      Rscript -e '
        options(repos = c(RSPM = Sys.getenv("RSPM"), CRAN = "https://cloud.r-project.org"))
        pak::pkg_install("rcmdcheck")
        rcmdcheck::rcmdcheck(
          args = c("--no-manual", "--no-vignettes", "--no-examples"),
          build_args = c("--no-manual", "--no-build-vignettes"),
          error_on = "error",
          check_dir = "check"
        )
      '
  artifacts:
    paths:
      - check/
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Run testthat tests (can run in parallel with r-cmd-check via DAG)
test:
  stage: test
  timeout: 60m
  needs:
    - job: r-cmd-check
      optional: true
  <<: *setup
  script:
    - |
      Rscript -e '
        options(repos = c(RSPM = Sys.getenv("RSPM"), CRAN = "https://cloud.r-project.org"))
        pak::pkg_install("testthat")
        # Run tests from source directory with JUnit output
        results <- testthat::test_local(reporter = testthat::JunitReporter$new(file = "test-results.xml"))
        # Check for failures
        if (any(as.data.frame(results)$failed > 0)) {
          quit(status = 1)
        }
      '
  artifacts:
    reports:
      junit: test-results.xml
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Code coverage with covr
coverage:
  stage: coverage
  timeout: 60m
  needs:
    - job: test
  <<: *setup
  script:
    - |
      Rscript -e '
        options(repos = c(RSPM = Sys.getenv("RSPM"), CRAN = "https://cloud.r-project.org"))
        pak::pkg_install("covr")

        cov <- covr::package_coverage(
          type = "tests",
          line_exclusions = list("src/RcppExports.cpp")
        )

        # Generate coverage report
        total_coverage <- covr::percent_coverage(cov)
        message(sprintf("Total coverage: %.1f%%", total_coverage))

        # Save coverage report as cobertura XML for GitLab
        covr::to_cobertura(cov, filename = "coverage.xml")

        # Upload to Codecov if token is available
        if (Sys.getenv("CODECOV_TOKEN") != "") {
          covr::codecov(token = Sys.getenv("CODECOV_TOKEN"))
        }
      '
  coverage: '/Total coverage: (\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Build pkgdown documentation site
pages:
  stage: deploy
  timeout: 60m
  needs:
    - job: r-cmd-check
  <<: *setup
  script:
    - |
      Rscript -e '
        options(repos = c(RSPM = Sys.getenv("RSPM"), CRAN = "https://cloud.r-project.org"))
        pak::pkg_install("pkgdown")
        pkgdown::build_site(override = list(destination = "public"))
      '
  artifacts:
    paths:
      - public
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  environment:
    name: production
    url: $CI_PAGES_URL

# CRAN-ready check (stricter, for releases)
cran-check:
  stage: check
  timeout: 1h
  <<: *setup
  script:
    - |
      Rscript -e '
        options(repos = c(RSPM = Sys.getenv("RSPM"), CRAN = "https://cloud.r-project.org"))
        pak::pkg_install(c("spelling", "urlchecker", "devtools"))

        # Spelling check
        message("=== Spelling Check ===")
        spell_errors <- spelling::spell_check_package()
        if (nrow(spell_errors) > 0) {
          print(spell_errors)
          message("Add valid words to inst/WORDLIST")
        }

        # URL check
        message("=== URL Check ===")
        url_results <- urlchecker::url_check()
        if (!is.null(url_results) && nrow(url_results) > 0) {
          print(url_results)
        }

        # Full CRAN check (NOTEs and warnings are allowed, only errors fail)
        message("=== R CMD check --as-cran ===")
        results <- devtools::check(cran = TRUE, error_on = "error")
      '
  artifacts:
    paths:
      - "*.Rcheck/"
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+/
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
      when: manual
      allow_failure: true

# Build source package for release (Nix-based, reproducible)
# Pulls R dependencies and C++ build artifacts from Attic cache
build-package:
  extends: .nix_base
  stage: deploy
  timeout: 30m
  needs:
    - job: r-cmd-check
  script:
    # Build tarball - Nix pulls cached R deps from Attic
    - nix build .#tarball --out-link result-tarball
    - cp result-tarball gnucashr_$(grep "^Version:" DESCRIPTION | cut -d' ' -f2).tar.gz
    - ls -la gnucashr_*.tar.gz
    # Push build closure to Attic for future builds
    - |
      if [ -n "$ATTIC_TOKEN" ]; then
        echo "Pushing build artifacts to Attic cache..."
        nix profile install nixpkgs#attic-client
        attic login tinyland https://nix-cache.fuzzy-dev.tinyland.dev "$ATTIC_TOKEN" || true
        attic push main result-tarball || echo "WARNING: Attic push failed (non-fatal)"
      fi
  artifacts:
    paths:
      - gnucashr_*.tar.gz
    expire_in: 3 months
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+/

# Create GitLab release
release:
  stage: deploy
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - job: build-package
      artifacts: true
    - job: cran-check
      artifacts: false
  script:
    - echo "Creating release for ${CI_COMMIT_TAG}"
  release:
    tag_name: $CI_COMMIT_TAG
    name: "gnucashr ${CI_COMMIT_TAG}"
    description: |
      ## gnucashr ${CI_COMMIT_TAG}

      See NEWS.md for full changelog.

      ### Installation

      From CRAN (after acceptance):
      ```r
      install.packages("gnucashr")
      ```

      From GitLab:
      ```r
      remotes::install_gitlab("tinyland/projects/gnucashr@${CI_COMMIT_TAG}")
      ```

      From GitHub:
      ```r
      remotes::install_github("Jesssullivan/gnucashr@${CI_COMMIT_TAG}")
      ```
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/
