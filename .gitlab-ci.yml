# GitLab CI/CD Pipeline for gnucashr R Package
# Nix-only pipeline with greedy Attic binary cache
#
# Architecture:
#   nix:build ─┬─> nix:cran-check ─┬─> nix:coverage
#              │                    └─> pages
#              └─> bazel:cpp (parallel)
#
# Cache Strategy:
#   - Attic: Greedy push/pull with watch-store mode
#   - Derivations pushed as they're built (not just at end)
#   - Downstream jobs immediately benefit from cached artifacts

stages:
  - build      # Build tarball + R CMD check
  - check      # CRAN compliance check
  - verify     # Coverage
  - deploy     # Pages, releases

variables:
  ATTIC_SERVER: "https://nix-cache.fuzzy-dev.tinyland.dev"
  ATTIC_CACHE: "main"
  NIX_CONFIG: |
    experimental-features = nix-command flakes
    accept-flake-config = true

default:
  tags:
    - linux
    - docker

# ============================================================
# Templates
# ============================================================

# Base template: Pull from cache only
.nix_base:
  image: nixos/nix:latest
  before_script:
    - nix --version
    # Install and configure Attic client
    - nix profile install nixpkgs#attic-client
    - attic login tinyland "$ATTIC_SERVER" "$ATTIC_TOKEN"
    # Configure Nix to use Attic as substituter (for pulling)
    - attic use "$ATTIC_CACHE"

# Greedy template: Watch-store for continuous push during build
.nix_greedy:
  image: nixos/nix:latest
  before_script:
    - nix --version
    # Install and configure Attic client
    - nix profile install nixpkgs#attic-client
    - attic login tinyland "$ATTIC_SERVER" "$ATTIC_TOKEN"
    # Configure Nix to use Attic as substituter (for pulling)
    - attic use "$ATTIC_CACHE"
    # Start watch-store in background for greedy push (main branch only)
    - |
      if [ "$CI_COMMIT_BRANCH" = "$CI_DEFAULT_BRANCH" ]; then
        echo "Starting greedy cache push (watch-store)..."
        attic watch-store "$ATTIC_CACHE" &
        echo $! > /tmp/watch-store.pid
      fi
  after_script:
    # Stop watch-store if running
    - |
      if [ -f /tmp/watch-store.pid ]; then
        kill $(cat /tmp/watch-store.pid) 2>/dev/null || true
        echo "Stopped watch-store"
      fi

# ============================================================
# BUILD STAGE - Greedy parallel builds
# ============================================================

nix:build:
  extends: .nix_greedy
  stage: build
  timeout: 45m
  script:
    - echo "=== Building gnucashr with greedy Attic cache ==="

    # Build sub-derivations (pulls from cache, pushes as built)
    - echo "Building R dependencies..."
    - nix build .#rDeps --out-link result-rdeps 2>&1 | tail -10

    - echo "Building C++ objects..."
    - nix build .#cppBuild --out-link result-cpp 2>&1 | tail -10

    - echo "Building tarball..."
    - nix build .#tarball --out-link result-tarball

    # Export tarball as artifact
    - VERSION=$(grep "^Version:" DESCRIPTION | cut -d' ' -f2)
    - cp result-tarball gnucashr_${VERSION}.tar.gz
    - ls -la gnucashr_*.tar.gz

    # Run R CMD check via Nix
    - echo "Running R CMD check..."
    - nix build .#checks.x86_64-linux.r-cmd-check --out-link result-check 2>&1 | tail -30
    - cp -r result-check/gnucashr.Rcheck check/ || mkdir -p check

    - echo "=== Build complete ==="
  artifacts:
    paths:
      - gnucashr_*.tar.gz
      - check/
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Bazel C++ build (parallel with nix:build)
bazel:cpp:
  image: gcr.io/bazel-public/bazel:latest
  stage: build
  timeout: 20m
  tags:
    - linux
    - docker
  script:
    - echo "=== Bazel C++ build (BuildBuddy remote cache) ==="
    - bazel --version
    # Use --enable_workspace for hybrid bzlmod/WORKSPACE mode
    - bazel build //src:gnucashr_cpp --config=ci --enable_workspace 2>&1 | tail -50
  cache:
    key: bazel-v3
    paths:
      - ~/.cache/bazel
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  allow_failure: true

# ============================================================
# CHECK STAGE - CRAN compliance
# ============================================================

nix:cran-check:
  extends: .nix_base
  stage: check
  timeout: 30m
  needs:
    - job: nix:build
      artifacts: true
  script:
    - echo "=== CRAN compliance checks ==="

    # Run full check on tarball
    - |
      nix develop --command bash -c '
        TARBALL=$(ls gnucashr_*.tar.gz | head -1)
        echo "Checking tarball: $TARBALL"

        # Spelling check
        Rscript -e "spelling::spell_check_package()" || true

        # URL check
        Rscript -e "urlchecker::url_check()" || true

        # CRAN check
        R CMD check --as-cran --no-manual "$TARBALL"
      '
  artifacts:
    paths:
      - "*.Rcheck/"
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+/
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ============================================================
# VERIFY STAGE - Coverage
# ============================================================

nix:coverage:
  extends: .nix_base
  stage: verify
  timeout: 30m
  needs:
    - job: nix:build
      artifacts: true
  script:
    - echo "=== Running coverage ==="
    - |
      nix develop --command bash -c '
        Rscript -e "
          cov <- covr::package_coverage(type = \"tests\", line_exclusions = list(\"src/RcppExports.cpp\"))
          total_coverage <- covr::percent_coverage(cov)
          message(sprintf(\"Total coverage: %.1f%%\", total_coverage))
          covr::to_cobertura(cov, filename = \"coverage.xml\")
        "
      '
  coverage: '/Total coverage: (\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ============================================================
# DEPLOY STAGE - Pages, releases
# ============================================================

pages:
  extends: .nix_base
  stage: deploy
  timeout: 30m
  needs:
    - job: nix:build
      artifacts: true
  script:
    - echo "=== Building pkgdown site for GitLab Pages ==="
    - |
      nix develop --command bash -c '
        Rscript -e "pkgdown::build_site(override = list(destination = \"public\"))"
      '
  artifacts:
    paths:
      - public
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  environment:
    name: production
    url: $CI_PAGES_URL

release:
  stage: deploy
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  tags:
    - linux
    - docker
  needs:
    - job: nix:build
      artifacts: true
    - job: nix:cran-check
      artifacts: false
  script:
    - echo "Creating release for ${CI_COMMIT_TAG}"
    - ls -la gnucashr_*.tar.gz
  release:
    tag_name: $CI_COMMIT_TAG
    name: "gnucashr ${CI_COMMIT_TAG}"
    description: |
      ## gnucashr ${CI_COMMIT_TAG}

      See NEWS.md for full changelog.

      ### Installation

      From CRAN (after acceptance):
      ```r
      install.packages("gnucashr")
      ```

      From GitLab:
      ```r
      remotes::install_gitlab("tinyland/projects/gnucashr@${CI_COMMIT_TAG}")
      ```

      From GitHub:
      ```r
      remotes::install_github("Jesssullivan/gnucashr@${CI_COMMIT_TAG}")
      ```
    assets:
      links:
        - name: "Source tarball"
          url: "${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/gnucashr_*.tar.gz"
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/
