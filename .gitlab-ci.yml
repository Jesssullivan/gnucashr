# GitLab CI/CD Pipeline for gnucashr R Package
# 2026-style: Greedy parallel execution with matrix flow and optimistic caching
#
# Architecture:
#   build (matrix) ─┬─> nix:tarball  ─┬─> check ─┬─> coverage
#                   │                  │          └─> pages
#                   └─> bazel:cpp     ─┘          └─> release
#
# Cache Strategy:
#   - Nix: Attic binary cache (pulls first, pushes on main)
#   - Bazel: BuildBuddy remote cache (automatic)
#   - GitLab: Artifact sharing between jobs

image: rocker/tidyverse:4.4.0

default:
  tags:
    - linux
    - docker

variables:
  R_LIBS_USER: "$CI_PROJECT_DIR/ci/lib"
  RSPM: "https://packagemanager.posit.co/cran/__linux__/jammy/latest"
  _R_CHECK_CRAN_INCOMING_REMOTE_: "false"
  _R_CHECK_FORCE_SUGGESTS_: "false"
  MAKEFLAGS: "-j4"
  NCPUS: "4"
  PKG_SYSREQS: "true"
  PKG_SYSREQS_DRY_RUN: "false"
  R_PKG_CACHE_DIR: "$CI_PROJECT_DIR/ci/pkg-cache"

# Reduced cache - Nix handles most caching now
cache:
  key: "r-deps-v4"
  paths:
    - ci/lib
    - ci/pkg-cache
  policy: pull-push

stages:
  - build      # Build artifacts (Nix tarball, Bazel C++)
  - check      # Validate (R CMD check, CRAN check)
  - verify     # Coverage, additional validation
  - deploy     # Pages, releases, cache warming

# ============================================================
# Templates
# ============================================================

.nix_base:
  image: nixos/nix:latest
  tags:
    - linux
    - docker
  variables:
    NIX_CONFIG: |
      experimental-features = nix-command flakes
      accept-flake-config = true
  before_script:
    - nix --version
    # Configure Attic as trusted substituter (append to system nix.conf)
    - |
      echo "extra-substituters = https://nix-cache.fuzzy-dev.tinyland.dev/main" >> /etc/nix/nix.conf
      echo "extra-trusted-public-keys = main:PBDvqG8OP3W2XF4QzuqWwZD/RhLRsE7ONxwM09kqTtw=" >> /etc/nix/nix.conf

.rocker_setup: &rocker_setup
  before_script:
    - mkdir -p $R_LIBS_USER
    - apt-get update -qq && apt-get install -y -qq libcurl4-openssl-dev libssl-dev libxml2-dev libgit2-dev libblas-dev liblapack-dev
    - |
      Rscript -e '
        options(repos = c(RSPM = Sys.getenv("RSPM"), CRAN = "https://cloud.r-project.org"))
        if (!requireNamespace("pak", quietly = TRUE)) {
          install.packages("pak", repos = sprintf("https://r-lib.github.io/p/pak/stable/%s/%s/%s", .Platform$pkgType, R.Version()$os, R.Version()$arch))
        }
        pak::pkg_install("local::.", dependencies = TRUE, upgrade = FALSE)
      '

# ============================================================
# BUILD STAGE - Greedy parallel artifact generation
# ============================================================

# Primary build: Nix tarball (reproducible, cached)
# This produces the canonical tarball used by all downstream jobs
nix:tarball:
  extends: .nix_base
  stage: build
  timeout: 30m
  script:
    # Pull from Attic cache (optimistic - expect cache hit)
    - echo "=== Building tarball (cache-first) ==="
    - nix build .#rDeps --out-link result-rdeps 2>&1 | head -20 || true
    - nix build .#cppBuild --out-link result-cpp 2>&1 | head -20 || true
    - nix build .#tarball --out-link result-tarball
    # Export tarball as artifact
    - VERSION=$(grep "^Version:" DESCRIPTION | cut -d' ' -f2)
    - cp result-tarball gnucashr_${VERSION}.tar.gz
    - ls -la gnucashr_*.tar.gz
    # Also run quick check
    - nix build .#checks.x86_64-linux.r-cmd-check --out-link result-check 2>&1 | tail -20
  artifacts:
    paths:
      - gnucashr_*.tar.gz
      - result-check/
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Secondary build: Bazel C++ (fine-grained caching)
# Runs in parallel with Nix, warms BuildBuddy cache
bazel:cpp:
  image: gcr.io/bazel-public/bazel:latest
  stage: build
  timeout: 20m
  tags:
    - linux
    - docker
  script:
    - echo "=== Bazel C++ build (remote cache) ==="
    - bazel --version
    - bazel build //src:gnucashr_cpp --config=ci 2>&1 | tail -30 || true
    - bazel info execution_log_binary_file 2>/dev/null || true
  cache:
    key: bazel-v2
    paths:
      - ~/.cache/bazel
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  allow_failure: true  # Bazel integration is supplementary

# ============================================================
# CHECK STAGE - Validation using built artifacts
# ============================================================

# Primary check: Uses Nix-built tarball
r-cmd-check:
  stage: check
  timeout: 45m
  needs:
    - job: nix:tarball
      artifacts: true
  <<: *rocker_setup
  script:
    - |
      Rscript -e '
        options(repos = c(RSPM = Sys.getenv("RSPM"), CRAN = "https://cloud.r-project.org"))
        pak::pkg_install("rcmdcheck")
        # Use pre-built tarball if available
        tarballs <- Sys.glob("gnucashr_*.tar.gz")
        if (length(tarballs) > 0) {
          message("Using pre-built tarball: ", tarballs[1])
          rcmdcheck::rcmdcheck(
            tarballs[1],
            args = c("--no-manual", "--no-vignettes"),
            error_on = "error",
            check_dir = "check"
          )
        } else {
          message("Building from source...")
          rcmdcheck::rcmdcheck(
            args = c("--no-manual", "--no-vignettes", "--no-examples"),
            build_args = c("--no-manual", "--no-build-vignettes"),
            error_on = "error",
            check_dir = "check"
          )
        }
      '
  artifacts:
    paths:
      - check/
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# CRAN-ready check (stricter, uses tarball)
cran-check:
  stage: check
  timeout: 1h
  needs:
    - job: nix:tarball
      artifacts: true
  <<: *rocker_setup
  script:
    - |
      Rscript -e '
        options(repos = c(RSPM = Sys.getenv("RSPM"), CRAN = "https://cloud.r-project.org"))
        pak::pkg_install(c("spelling", "urlchecker", "devtools"))

        message("=== Spelling Check ===")
        spell_errors <- spelling::spell_check_package()
        if (nrow(spell_errors) > 0) print(spell_errors)

        message("=== URL Check ===")
        url_results <- urlchecker::url_check()
        if (!is.null(url_results) && nrow(url_results) > 0) print(url_results)

        message("=== R CMD check --as-cran ===")
        tarballs <- Sys.glob("gnucashr_*.tar.gz")
        if (length(tarballs) > 0) {
          # Check the pre-built tarball
          system2("R", c("CMD", "check", "--as-cran", "--no-manual", tarballs[1]))
        } else {
          devtools::check(cran = TRUE, error_on = "error")
        }
      '
  artifacts:
    paths:
      - "*.Rcheck/"
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+/
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ============================================================
# VERIFY STAGE - Coverage and additional validation
# ============================================================

coverage:
  stage: verify
  timeout: 45m
  needs:
    - job: r-cmd-check
      optional: true
  <<: *rocker_setup
  script:
    - |
      Rscript -e '
        options(repos = c(RSPM = Sys.getenv("RSPM"), CRAN = "https://cloud.r-project.org"))
        pak::pkg_install("covr")
        cov <- covr::package_coverage(type = "tests", line_exclusions = list("src/RcppExports.cpp"))
        total_coverage <- covr::percent_coverage(cov)
        message(sprintf("Total coverage: %.1f%%", total_coverage))
        covr::to_cobertura(cov, filename = "coverage.xml")
        if (Sys.getenv("CODECOV_TOKEN") != "") {
          covr::codecov(token = Sys.getenv("CODECOV_TOKEN"))
        }
      '
  coverage: '/Total coverage: (\d+\.\d+)%/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ============================================================
# DEPLOY STAGE - Pages, releases, cache warming
# ============================================================

# Pages: Build pkgdown site
pages:
  stage: deploy
  timeout: 30m
  needs:
    - job: r-cmd-check
      optional: true
  <<: *rocker_setup
  script:
    - |
      Rscript -e '
        options(repos = c(RSPM = Sys.getenv("RSPM"), CRAN = "https://cloud.r-project.org"))
        pak::pkg_install("pkgdown")
        pkgdown::build_site(override = list(destination = "public"))
      '
  artifacts:
    paths:
      - public
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  environment:
    name: production
    url: $CI_PAGES_URL

# Cache warming: Push all Nix derivations to Attic
# Runs after successful builds to warm cache for future pipelines
nix:cache-push:
  extends: .nix_base
  stage: deploy
  timeout: 30m
  needs:
    - job: nix:tarball
      artifacts: true
  script:
    - echo "=== Pushing to Attic cache ==="
    # Rebuild derivations (instant if cached locally)
    - nix build .#rDeps --out-link result-rdeps
    - nix build .#cppBuild --out-link result-cpp
    - nix build .#tarball --out-link result-tarball
    - nix build .#devShells.x86_64-linux.default --out-link result-devshell || true
    # Push to Attic
    - |
      if [ -n "$ATTIC_TOKEN" ]; then
        nix profile install nixpkgs#attic-client
        attic login tinyland https://nix-cache.fuzzy-dev.tinyland.dev "$ATTIC_TOKEN"
        attic push main result-rdeps result-cpp result-tarball result-devshell 2>&1 | tail -20 || echo "Some pushes failed (non-fatal)"
        echo "Cache push complete"
      else
        echo "ATTIC_TOKEN not set, skipping"
      fi
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# Release: Create GitLab release with tarball
release:
  stage: deploy
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - job: nix:tarball
      artifacts: true
    - job: cran-check
      artifacts: false
  script:
    - echo "Creating release for ${CI_COMMIT_TAG}"
    - ls -la gnucashr_*.tar.gz
  release:
    tag_name: $CI_COMMIT_TAG
    name: "gnucashr ${CI_COMMIT_TAG}"
    description: |
      ## gnucashr ${CI_COMMIT_TAG}

      See NEWS.md for full changelog.

      ### Installation

      From CRAN (after acceptance):
      ```r
      install.packages("gnucashr")
      ```

      From GitLab:
      ```r
      remotes::install_gitlab("tinyland/projects/gnucashr@${CI_COMMIT_TAG}")
      ```

      From GitHub:
      ```r
      remotes::install_github("Jesssullivan/gnucashr@${CI_COMMIT_TAG}")
      ```
    assets:
      links:
        - name: "Source tarball"
          url: "${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/gnucashr_*.tar.gz"
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/
