# GitLab CI/CD Pipeline for gnucashr R Package
# Nix-only pipeline with greedy Attic binary cache
#
# Architecture:
#   nix:build ─┬─> nix:cran-check ─┬─> nix:coverage
#              │                    └─> pages
#              └─> bazel:cpp (parallel)
#
# Cache Strategy:
#   - Attic: Greedy push/pull with watch-store mode
#   - Derivations pushed as they're built (not just at end)
#   - Downstream jobs immediately benefit from cached artifacts

stages:
  - build      # Build tarball + R CMD check
  - check      # CRAN compliance check
  - verify     # Coverage
  - deploy     # Pages, releases

variables:
  ATTIC_SERVER: "https://nix-cache.fuzzy-dev.tinyland.dev"
  ATTIC_CACHE: "main"
  NIX_CONFIG: |
    experimental-features = nix-command flakes
    accept-flake-config = true

default:
  tags:
    - linux
    - docker

# ============================================================
# Templates
# ============================================================

# Base template: Pull from cache only
.nix_base:
  image: nixos/nix:latest
  variables:
    # Disable renv auto-activation (we use Nix for dependencies)
    RENV_ACTIVATE_PROJECT: "FALSE"
  before_script:
    - nix --version
    # Install and configure Attic client
    - nix profile install nixpkgs#attic-client
    - attic login tinyland "$ATTIC_SERVER" "$ATTIC_TOKEN"
    # Configure Nix to use Attic as substituter (for pulling)
    - attic use "$ATTIC_CACHE"
    # Remove .Rprofile to prevent renv from interfering
    - rm -f .Rprofile

# Greedy template: Watch-store for continuous push during build
.nix_greedy:
  image: nixos/nix:latest
  variables:
    # Disable renv auto-activation (we use Nix for dependencies)
    RENV_ACTIVATE_PROJECT: "FALSE"
  before_script:
    - nix --version
    # Install and configure Attic client
    - nix profile install nixpkgs#attic-client
    - attic login tinyland "$ATTIC_SERVER" "$ATTIC_TOKEN"
    # Configure Nix to use Attic as substituter (for pulling)
    - attic use "$ATTIC_CACHE"
    # Remove .Rprofile to prevent renv from interfering
    - rm -f .Rprofile
    # Start watch-store in background for greedy push (main branch only)
    - |
      if [ "$CI_COMMIT_BRANCH" = "$CI_DEFAULT_BRANCH" ]; then
        echo "Starting greedy cache push (watch-store)..."
        attic watch-store "$ATTIC_CACHE" &
        echo $! > /tmp/watch-store.pid
      fi
  after_script:
    # Stop watch-store if running
    - |
      if [ -f /tmp/watch-store.pid ]; then
        kill $(cat /tmp/watch-store.pid) 2>/dev/null || true
        echo "Stopped watch-store"
      fi

# ============================================================
# BUILD STAGE - Greedy parallel builds
# ============================================================

nix:build:
  extends: .nix_greedy
  stage: build
  timeout: 45m
  script:
    - echo "=== Building gnucashr with greedy Attic cache ==="

    # Build sub-derivations in PARALLEL (pulls from cache, pushes as built)
    # watch-store pushes each derivation as it completes
    - echo "Building all derivations in parallel..."
    - |
      nix build \
        .#rDeps \
        .#cppBuild \
        .#tarball \
        .#checks.x86_64-linux.r-cmd-check \
        --out-link result \
        --max-jobs 4 \
        2>&1 | tail -50

    # Export tarball as artifact
    - VERSION=$(grep "^Version:" DESCRIPTION | cut -d' ' -f2)
    - nix build .#tarball --out-link result-tarball
    - cp result-tarball gnucashr_${VERSION}.tar.gz
    - ls -la gnucashr_*.tar.gz

    # Copy check results
    - nix build .#checks.x86_64-linux.r-cmd-check --out-link result-check
    - cp -r result-check/gnucashr.Rcheck check/ || mkdir -p check

    - echo "=== Build complete ==="
  artifacts:
    paths:
      - gnucashr_*.tar.gz
      - check/
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_COMMIT_TAG

# Bazel build graph validation (parallel with nix:build)
# Validates Bazel configuration without attempting C++ compilation
# (C++ files require Rcpp headers which are provided by Nix, not Bazel)
bazel:cpp:
  extends: .nix_base
  stage: build
  timeout: 10m
  script:
    - echo "=== Bazel configuration validation ==="
    - nix profile install nixpkgs#bazel_7
    - bazel --version
    # Query build graph to validate configuration
    - bazel query //... --enable_workspace
    - echo "=== Build graph validated ==="
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  allow_failure: true

# ============================================================
# CHECK STAGE - CRAN compliance
# ============================================================

nix:cran-check:
  extends: .nix_base
  stage: check
  timeout: 30m
  needs:
    - job: nix:build
      artifacts: true
  script:
    - echo "=== CRAN compliance checks ==="

    # Run full check on tarball
    - |
      nix develop --command bash -c '
        TARBALL=$(ls gnucashr_*.tar.gz | head -1)
        echo "Checking tarball: $TARBALL"

        # Spelling check
        Rscript -e "spelling::spell_check_package()" || true

        # URL check
        Rscript -e "urlchecker::url_check()" || true

        # CRAN check
        R CMD check --as-cran --no-manual "$TARBALL"
      '
  artifacts:
    paths:
      - "*.Rcheck/"
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+/
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

# ============================================================
# VERIFY STAGE - Coverage
# ============================================================

nix:coverage:
  extends: .nix_base
  stage: verify
  timeout: 30m
  needs:
    - job: nix:build
      artifacts: true
  script:
    - echo "=== Running coverage via Nix derivation ==="
    # Use cached coverage derivation (rebuilds only if source changed)
    - nix build .#coverage --out-link result-coverage
    - cp result-coverage/coverage.xml .
    - cat result-coverage/summary.txt
  coverage: '/line-rate="([0-9.]+)"/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ============================================================
# DEPLOY STAGE - Pages, releases
# ============================================================

pages:
  extends: .nix_base
  stage: deploy
  timeout: 30m
  needs:
    - job: nix:build
      artifacts: true
  script:
    - echo "=== Building pkgdown site via Nix derivation ==="
    # Use cached pkgdown derivation (rebuilds only if source changed)
    - nix build .#pkgdown --out-link result-pkgdown
    - cp -r result-pkgdown public
  artifacts:
    paths:
      - public
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH
  environment:
    name: production
    url: $CI_PAGES_URL

release:
  stage: deploy
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  tags:
    - linux
    - docker
  needs:
    - job: nix:build
      artifacts: true
    - job: nix:cran-check
      artifacts: false
  script:
    - echo "Creating release for ${CI_COMMIT_TAG}"
    - ls -la gnucashr_*.tar.gz
  release:
    tag_name: $CI_COMMIT_TAG
    name: "gnucashr ${CI_COMMIT_TAG}"
    description: |
      ## gnucashr ${CI_COMMIT_TAG}

      See NEWS.md for full changelog.

      ### Installation

      From CRAN (after acceptance):
      ```r
      install.packages("gnucashr")
      ```

      From GitLab:
      ```r
      remotes::install_gitlab("tinyland/projects/gnucashr@${CI_COMMIT_TAG}")
      ```

      From GitHub:
      ```r
      remotes::install_github("Jesssullivan/gnucashr@${CI_COMMIT_TAG}")
      ```
    assets:
      links:
        - name: "Source tarball"
          url: "${CI_PROJECT_URL}/-/jobs/${CI_JOB_ID}/artifacts/file/gnucashr_*.tar.gz"
  rules:
    - if: $CI_COMMIT_TAG =~ /^v[0-9]+\.[0-9]+\.[0-9]+$/
